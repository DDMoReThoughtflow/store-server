/* ----------------------------------------------------------------------------
 * This file is part of ThoughtFlow Provenance Server.  
 * 
 * Copyright (C) 2016 jointly by the following organisation:- 
 * 1. DDMoRe Foundation
 * 2. Cyprotex Discovery Ltd, Macclesfield, England, UK
 *
 * This library is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License as published by
 * the Free Software Foundation. A copy of the license agreement is provided
 * in the file named "LICENSE.txt" included with this software distribution.
 * ----------------------------------------------------------------------------
 */

package eu.ddmore.provn.client;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Date;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class Utils {
	private static final String LBL_PREFIX_SPARQL = "PREFIX";
	private static final String LBL_PREFIX_TTL = "@prefix";
	private static final String LBL_SPARQL_COMMENT = "#";
	private static final String reg_pattern1 = "\"(ddmore:.+)\"(\\^\\^xsd:string)"; 
	private static final String reg_pattern2 = "rdfs:label.+(\".+\")";
	private static final String reg_pattern3 = "ddmore:mentionOf_"; 
	private static final String xsd_string_postfix = "^^xsd:string";
	
	/**
	 * Adjust the TTL generated by Open Provenance Toolbox to make graph more friendly for querying.
	 * @param lines Input Lines
	 * @return List<String>
	 */
	public static List<String> adjustTTL(List<String> lines) {
		List<String> output = new ArrayList<String>();
		if (lines == null) return output;
		if (lines.isEmpty()) return output;
		
		Pattern p1 = Pattern.compile(reg_pattern1);
		Pattern p2 = Pattern.compile(reg_pattern2);
		Pattern p3 = Pattern.compile(reg_pattern3);
		
		for (String line : lines) {
			Matcher m1 = p1.matcher(line);
			Matcher m2 = p2.matcher(line);
			Matcher m3 = p3.matcher(line);
			
			if (m1.find()) line = line.replace(m1.group(0), m1.group(1));
			else if (m2.find()) {
				String match = m2.group(1);
				String new_value = match + xsd_string_postfix;
				line = line.replace(match, new_value);
			} else if (m3.find())			{
				line = line.replace(m3.group(0), "_:mentionOf_");
			}
			
			output.add(line);
		}
		
		return output;
	}
	
	/**
	 * Create the SparQL insert data command from a buffered TTL graph file.
	 * @param lines TTL file read into a String vector.
	 * @return String
	 */
	public static String createInsertGraphSparQL(String [] lines) {
		if (lines == null) throw new NullPointerException("Triples buffer is NULL");
		else if (lines.length == 0) throw new IllegalStateException("Triples buffer is not NULL");
		
		List<String> prefixes = new ArrayList<String>();
		List<String> triples = new ArrayList<String>();
		
		for (String line : lines) {
			if (line == null) continue;
			line = line.trim();
			if (line.startsWith(LBL_PREFIX_TTL)) {
				line = line.replace(LBL_PREFIX_TTL, LBL_PREFIX_SPARQL);
				line = line.replace(" .", "");
				prefixes.add(line);
			} else
				triples.add(line);
		}
		
		List<String> output_lines = new ArrayList<String>();
		for (String prefix : prefixes) output_lines.add(prefix);
			
		output_lines.add(LBL_SPARQL_COMMENT + " Dated:" + new Date());
		output_lines.add("");
		output_lines.add("INSERT DATA {");

		for (String triple : triples) {
			if (triple.startsWith(LBL_SPARQL_COMMENT)) continue;
			if (triple.isEmpty()) continue;
			output_lines.add(triple);
		}
		output_lines.add("");
		output_lines.add("}");
		
		output_lines = adjustTTL(output_lines);
		StringBuffer stmt = new StringBuffer();
		final String format = "%s\n";
		for (String output_line : output_lines) stmt.append(String.format(format, output_line));
		
		return stmt.toString();
	}
	
	/**
	 * Read a file and concatonate contents into a list.
	 * @param filepath Input Filepath
	 * @return List<String>
	 * @throws IOException
	 */
	public static List<String> readFile(String filepath) throws IOException {
		BufferedReader fin = new BufferedReader(new FileReader(filepath));
		String line = null;
		
		List<String> lines = new ArrayList<String>();
		while ((line = fin.readLine()) != null) {
			line = line.trim();
			lines.add(line);
		}
		fin.close();
		
		return lines;
	}
	
	/**
	 * Read a file and concatonate contents into a list.
	 * @param filepath Input Filepath
	 * @return String
	 * @throws IOException
	 */
	public static String readFile_(String filepath) throws IOException {
		BufferedReader fin = new BufferedReader(new FileReader(filepath));
		
		String line = null;
		StringBuffer stmt = new StringBuffer();
		while ((line = fin.readLine()) != null) {
			stmt.append(line.trim());
			stmt.append("\n");
		}
		
		fin.close();
		
		return stmt.toString();
	}
}
